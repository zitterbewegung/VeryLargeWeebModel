#!/usr/bin/env python3
"""Run task JSONL for knot enumeration with SQLite-backed status tracking."""

from __future__ import annotations

import argparse
import json
import sqlite3
import subprocess
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional


def now_utc_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Execute task queue generated by generate_enumeration_tasks.py."
    )
    parser.add_argument("--tasks", type=Path, required=True, help="Task JSONL file.")
    parser.add_argument(
        "--db",
        type=Path,
        required=True,
        help="SQLite DB path (e.g. checkpoints/enumeration_state.sqlite).",
    )
    parser.add_argument(
        "--run-id",
        type=str,
        default=None,
        help="Run identifier. Default: auto timestamp.",
    )
    parser.add_argument(
        "--workspace-root",
        type=Path,
        required=True,
        help="Workspace root used as cwd for commands.",
    )
    parser.add_argument(
        "--max-tasks",
        type=int,
        default=None,
        help="Stop after running this many tasks.",
    )
    parser.add_argument(
        "--stage",
        type=str,
        default=None,
        help="Optional stage filter.",
    )
    parser.add_argument(
        "--crossing",
        type=int,
        default=None,
        help="Optional crossing filter.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print runnable tasks without executing commands.",
    )
    return parser.parse_args()


def connect_db(path: Path) -> sqlite3.Connection:
    path.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(path)
    conn.row_factory = sqlite3.Row
    return conn


def ensure_run_row(conn: sqlite3.Connection, run_id: str, manifest_path: str) -> None:
    conn.execute(
        """
        INSERT OR IGNORE INTO runs(run_id, created_at_utc, manifest_path, notes)
        VALUES (?, ?, ?, ?)
        """,
        (run_id, now_utc_iso(), manifest_path, "generated by run_enumeration_tasks.py"),
    )
    conn.commit()


def load_tasks(path: Path) -> List[Dict[str, object]]:
    tasks: List[Dict[str, object]] = []
    for line in path.read_text(encoding="utf-8").splitlines():
        text = line.strip()
        if not text:
            continue
        obj = json.loads(text)
        if not isinstance(obj, dict):
            continue
        tasks.append(obj)
    return tasks


def insert_task_if_missing(
    conn: sqlite3.Connection,
    run_id: str,
    task: Dict[str, object],
    log_path: Path,
) -> None:
    conn.execute(
        """
        INSERT OR IGNORE INTO tasks(
          task_id, run_id, stage, crossing, shard, status, command,
          input_path, output_path, checkpoint_path, log_path
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
        (
            str(task["task_id"]),
            run_id,
            str(task["stage"]),
            int(task["crossing"]),
            int(task["shard"]),
            "pending",
            str(task["command"]),
            str(task.get("input_path", "")),
            str(task.get("output_path", "")),
            str(task.get("checkpoint_path", "")),
            str(log_path),
        ),
    )


def get_task_status(conn: sqlite3.Connection, task_id: str) -> Optional[str]:
    row = conn.execute(
        "SELECT status FROM tasks WHERE task_id = ?",
        (task_id,),
    ).fetchone()
    if row is None:
        return None
    return str(row["status"])


def update_task_status(
    conn: sqlite3.Connection,
    task_id: str,
    status: str,
    started_at_utc: Optional[str] = None,
    finished_at_utc: Optional[str] = None,
    exit_code: Optional[int] = None,
) -> None:
    conn.execute(
        """
        UPDATE tasks
        SET status = ?,
            started_at_utc = COALESCE(?, started_at_utc),
            finished_at_utc = COALESCE(?, finished_at_utc),
            exit_code = COALESCE(?, exit_code)
        WHERE task_id = ?
        """,
        (status, started_at_utc, finished_at_utc, exit_code, task_id),
    )
    conn.commit()


def task_is_runnable(conn: sqlite3.Connection, task: Dict[str, object]) -> bool:
    dep = task.get("depends_on")
    if dep in (None, "", "null"):
        return True
    dep_status = get_task_status(conn, str(dep))
    return dep_status == "completed"


def run_task(
    conn: sqlite3.Connection,
    workspace_root: Path,
    task: Dict[str, object],
    dry_run: bool,
) -> bool:
    task_id = str(task["task_id"])
    command = str(task["command"])

    row = conn.execute(
        "SELECT log_path FROM tasks WHERE task_id = ?",
        (task_id,),
    ).fetchone()
    if row is None:
        raise RuntimeError(f"Task not found in DB: {task_id}")
    log_path = Path(str(row["log_path"]))
    log_path.parent.mkdir(parents=True, exist_ok=True)

    if dry_run:
        print(f"[DRY-RUN] {task_id}: {command}")
        return True

    started = now_utc_iso()
    update_task_status(conn, task_id, status="running", started_at_utc=started)

    with log_path.open("a", encoding="utf-8") as handle:
        handle.write(f"\n=== {task_id} started {started} UTC ===\n")
        handle.write(command + "\n\n")
        handle.flush()
        result = subprocess.run(
            ["/bin/bash", "-lc", command],
            cwd=str(workspace_root),
            stdout=handle,
            stderr=subprocess.STDOUT,
            text=True,
        )

    finished = now_utc_iso()
    if result.returncode == 0:
        update_task_status(
            conn,
            task_id,
            status="completed",
            finished_at_utc=finished,
            exit_code=0,
        )
        print(f"[OK] {task_id}")
        return True

    update_task_status(
        conn,
        task_id,
        status="failed",
        finished_at_utc=finished,
        exit_code=result.returncode,
    )
    print(f"[FAIL] {task_id} exit={result.returncode}")
    return False


def main() -> int:
    args = parse_args()
    run_id = args.run_id or datetime.now().strftime("enum_%Y%m%d_%H%M%S")
    tasks = load_tasks(args.tasks)

    if args.stage is not None:
        tasks = [task for task in tasks if str(task.get("stage")) == args.stage]
    if args.crossing is not None:
        tasks = [task for task in tasks if int(task.get("crossing")) == args.crossing]

    if not tasks:
        print("No tasks selected.")
        return 0

    conn = connect_db(args.db)
    try:
        ensure_run_row(conn, run_id, str(args.tasks))

        for task in tasks:
            task_id = str(task["task_id"])
            stage = str(task["stage"])
            crossing = int(task["crossing"])
            shard = int(task["shard"])
            log_path = args.workspace_root / "logs" / "tasks" / f"{task_id}.log"

            insert_task_if_missing(conn, run_id, task, log_path)
            existing = get_task_status(conn, task_id)
            if existing in {"completed", "failed"}:
                continue

            # Keep metadata aligned for tasks already inserted as pending.
            conn.execute(
                """
                UPDATE tasks
                SET run_id = ?, stage = ?, crossing = ?, shard = ?,
                    command = ?, input_path = ?, output_path = ?, checkpoint_path = ?, log_path = ?
                WHERE task_id = ?
                """,
                (
                    run_id,
                    stage,
                    crossing,
                    shard,
                    str(task["command"]),
                    str(task.get("input_path", "")),
                    str(task.get("output_path", "")),
                    str(task.get("checkpoint_path", "")),
                    str(log_path),
                    task_id,
                ),
            )
        conn.commit()

        completed_count = 0
        attempted = 0
        task_map: Dict[str, Dict[str, object]] = {str(task["task_id"]): task for task in tasks}

        while True:
            progress = False
            for task_id, task in task_map.items():
                status = get_task_status(conn, task_id)
                if status in {"completed", "failed", "running"}:
                    continue
                if not task_is_runnable(conn, task):
                    continue
                if args.max_tasks is not None and attempted >= args.max_tasks:
                    print("Reached --max-tasks limit.")
                    return 0

                attempted += 1
                success = run_task(
                    conn=conn,
                    workspace_root=args.workspace_root,
                    task=task,
                    dry_run=args.dry_run,
                )
                progress = True
                if success:
                    completed_count += 1
                else:
                    print("Stopping after first failure.")
                    return 1
            if not progress:
                break

        pending = [
            task_id
            for task_id in task_map
            if get_task_status(conn, task_id) not in {"completed", "failed"}
        ]
        print(f"Run complete: run_id={run_id}, completed={completed_count}, pending={len(pending)}")
        if pending:
            print("Pending tasks likely blocked by dependencies:")
            for task_id in pending[:20]:
                print(f"  - {task_id}")
            if len(pending) > 20:
                print(f"  ... and {len(pending) - 20} more")
        return 0
    finally:
        conn.close()


if __name__ == "__main__":
    raise SystemExit(main())
